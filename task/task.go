package task

import (
	"sync"
	"time"

	"github.com/google/uuid"
)

type TaskState int

const (
	TaskPending TaskState = iota
	TaskRunning
	TaskCompleted
	TaskFailed
)

type Task struct {
	mu          sync.RWMutex // protects all fields below
	ID          uuid.UUID    // Unique task identifier (generated by Manager)
	Name        string       // User-friendly name
	Image       string       // Container image to run
	Args        []string     // Command arguments for container
	State       TaskState    // Current lifecycle state
	ContainerID string       // Docker container ID (populated once running)
	WorkerID    uuid.UUID    // Assigned worker (set by scheduler)
	Error       string       // Error message if failed
	CreatedAt   time.Time
	StartedAt   time.Time
	FinishedAt  time.Time
}

func NewTask(name, image string, args []string) *Task {
	return &Task{
		ID:        uuid.New(),
		Name:      name,
		Image:     image,
		Args:      args,
		State:     TaskPending,
		CreatedAt: time.Now(),
	}
}

// SetState atomically updates the task state.
func (t *Task) SetState(state TaskState) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.State = state
}

// SetContainerID atomically updates the container ID.
func (t *Task) SetContainerID(id string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.ContainerID = id
}

// SetError atomically sets the error message and marks task as failed.
func (t *Task) SetError(err string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.Error = err
	t.State = TaskFailed
	t.FinishedAt = time.Now()
}

// MarkCompleted atomically marks the task as completed.
func (t *Task) MarkCompleted() {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.State = TaskCompleted
	t.FinishedAt = time.Now()
}

// MarkRunning atomically marks the task as running with start time and container ID.
func (t *Task) MarkRunning(containerID string) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.State = TaskRunning
	t.ContainerID = containerID
	t.StartedAt = time.Now()
}

// GetContainerID safely reads the container ID.
func (t *Task) GetContainerID() string {
	t.mu.RLock()
	defer t.mu.RUnlock()
	return t.ContainerID
}

// SetWorkerID atomically updates the worker ID.
func (t *Task) SetWorkerID(workerID uuid.UUID) {
	t.mu.Lock()
	defer t.mu.Unlock()
	t.WorkerID = workerID
}

// Clone creates a deep copy of the task for storage isolation.
func (t *Task) Clone() *Task {
	t.mu.RLock()
	defer t.mu.RUnlock()
	argsCopy := make([]string, len(t.Args))
	copy(argsCopy, t.Args)
	return &Task{
		ID:          t.ID,
		Name:        t.Name,
		Image:       t.Image,
		Args:        argsCopy,
		State:       t.State,
		ContainerID: t.ContainerID,
		WorkerID:    t.WorkerID,
		Error:       t.Error,
		CreatedAt:   t.CreatedAt,
		StartedAt:   t.StartedAt,
		FinishedAt:  t.FinishedAt,
	}
}
