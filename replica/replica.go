package replica

import (
	"sync"
	"time"

	"github.com/google/uuid"
)

type ReplicaState int

const (
	ReplicaPending ReplicaState = iota
	ReplicaRunning
	ReplicaCompleted
	ReplicaFailed
)

type Replica struct {
	mu          sync.RWMutex // protects all fields below
	ID          uuid.UUID    // Unique replica identifier (generated by Manager)
	Name        string       // User-friendly name
	Image       string       // Container image to run
	Cmd         []string     // Override container CMD
	State       ReplicaState // Current lifecycle state
	ContainerID string       // Docker container ID (populated once running)
	WorkerID    uuid.UUID    // Assigned worker (set by scheduler)
	ServiceID   uuid.UUID    // Parent service ID
	ServiceName string       // Parent service name (cached for queries)
	ReplicaID   int          // Replica number within service (0-indexed)
	Error       string       // Error message if failed
	CreatedAt   time.Time
	StartedAt   time.Time
	FinishedAt  time.Time
}

// NewReplica creates a new Replica for a service.
func NewReplica(name, image string, cmd []string) *Replica {
	if cmd == nil {
		cmd = []string{}
	}
	return &Replica{
		ID:        uuid.New(),
		Name:      name,
		Image:     image,
		Cmd:       cmd,
		State:     ReplicaPending,
		CreatedAt: time.Now(),
	}
}

// Deprecated: Use NewReplica instead. This is kept for backward compatibility during refactoring.
func Newreplica(name, image string, cmd []string) *Replica {
	return NewReplica(name, image, cmd)
}

// SetState atomically updates the replica state.
func (r *Replica) SetState(state ReplicaState) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.State = state
}

// SetContainerID atomically updates the container ID.
func (r *Replica) SetContainerID(id string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.ContainerID = id
}

// SetError atomically sets the error message and marks replica as failed.
func (r *Replica) SetError(err string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.Error = err
	r.State = ReplicaFailed
	r.FinishedAt = time.Now()
}

// MarkCompleted atomically marks the replica as completed.
func (r *Replica) MarkCompleted() {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.State = ReplicaCompleted
	r.FinishedAt = time.Now()
}

// MarkRunning atomically marks the replica as running with start time and container ID.
func (r *Replica) MarkRunning(containerID string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.State = ReplicaRunning
	r.ContainerID = containerID
	r.StartedAt = time.Now()
}

// GetContainerID safely reads the container ID.
func (r *Replica) GetContainerID() string {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.ContainerID
}

// SetWorkerID atomically updates the worker ID.
func (r *Replica) SetWorkerID(workerID uuid.UUID) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.WorkerID = workerID
}

// Clone creates a deep copy of the replica for storage isolation.
func (r *Replica) Clone() *Replica {
	r.mu.RLock()
	defer r.mu.RUnlock()
	cmdCopy := make([]string, len(r.Cmd))
	copy(cmdCopy, r.Cmd)
	return &Replica{
		ID:          r.ID,
		Name:        r.Name,
		Image:       r.Image,
		Cmd:         cmdCopy,
		State:       r.State,
		ContainerID: r.ContainerID,
		WorkerID:    r.WorkerID,
		ServiceID:   r.ServiceID,
		ServiceName: r.ServiceName,
		ReplicaID:   r.ReplicaID,
		Error:       r.Error,
		CreatedAt:   r.CreatedAt,
		StartedAt:   r.StartedAt,
		FinishedAt:  r.FinishedAt,
	}
}
